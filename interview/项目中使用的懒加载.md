## 懒加载
需求点：由于需要为列表画图，因此考虑性能根据屏幕滑动来渲染画面

1. 当屏幕停止滑动，则去渲染画图
监听外层div的scroll事件，然后结合防抖动 _.debounce($.proxy(cb)); 
2. 获取当前屏幕的列表数据  

计算：  
每条数据占据页面的高度，h = $(item).height()  
滚动条滚动的距离（scrollTop），t = $(container).scrollTop()  
被滚出当前窗口的数据条数，sum = t/h  
当前窗口出现的第一条数据序号，sum+1  
第一条数据占据当前窗口的高度,窗口的容纳数据量，remainH = h-t%h  
窗口还能容纳的数量，($(container).height() - remainH)/h
然后观察还剩多少页  ($(container).height() - remainH)%h == 0
* 要区分页面与窗口
判断存储数据列表是否含有该数据，如果没有则获取数据

3. 画图函数，并将已经绘画出的数据存入数组记录（画图的同时一起渲染在页面）
判断已绘画的数组是否含有该数据，如果没有则重新绘画


## ios系统键盘导致表单的焦点错位
```
resizeWindow: function(){
  document,documentElement.scrollerTop || document,body.scrollerTop || 0
  window.scrollTo(0,Math.max(sh-1,0))
}
```

## 排序
不同浏览器对于相同值得排序不一致，因此需要设置index来标志原来元素的位置顺序  
```
//异常值排在最后
arr.sort(function(d1,d2){
  var val1 = d1[key1]?(d1[key1][key2] ? pareseFloat(d1[key1][key2]):'--'):'--';
  var val2 = d2[key1]?(d2[key1][key2] ? pareseFloat(d2[key1][key2]):'--'):'--';
  if(val1 === null || val1 ===''){
    value = -99999999 
  }
  //val2同理
  return val1<val2 ? 1 : (val1?val2 ? -1 :(d1.id>d2.id ? 1 : -1))
})

```
