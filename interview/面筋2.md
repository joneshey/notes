## 加载海量数据
思路：  
1. 减少dom操作的页面回流 => 使用DocumentFragment 
2. 监听海量元素可以通过父元素进行事件委托
3. 请求ajax频数
4. window.requestAnimationFrame
window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。  
该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行  
返回值：一个 long 整数，请求 ID ，是回调列表中唯一的标识。这个值给 window.cancelAnimationFrame() 以取消回调函数  
注意：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()  

## 作用域
```javascript
function Foo() {
    //没有var声明，先向当前Foo函数作用域内寻找getName变量，再向当前函数作用域上层。
    即外层作用域内寻找是否含有getName变量，也就是第二问中的alert(4)函数，将此变量的值赋值为 function(){alert(1)}。 
    getName = function () { alert (1); };
    return this;
}
Foo.getName = function () { alert (2);};
Foo.prototype.getName = function () { alert (3);};
var getName = function () { alert (4);};
function getName() { alert (5);}

//答案：
//首先定义了一个叫Foo的函数，之后为Foo创建了一个叫getName的静态属性存储了一个匿名函数，之后为Foo的原型对象新创建了一个叫getName的匿名函数。
//之后又通过函数变量表达式创建了一个getName的函数，最后再声明一个叫getName函数。
Foo.getName(); //2

getName(); //4，因为function优先级比var高，然后getName = function()时，覆盖了getName   

Foo().getName(); //1，不一样的是，先执行foo，然后将this指向window，再执行getName，因此调用是window。

getName(); //1，则是再访问getName，由于Foo的getName没有var声明，因此是全局的变量，并覆盖了覆盖外层作用域的alert(4)

new Foo.getName(); //2，点（.）的优先级高于new操作，遂相当于是:new (Foo.getName)();所以实际上将getName函数作为了构造函数来执行

new Foo().getName(); 
//3，看运算符优先级括号高于new，实际执行为(new Foo()).getName()，遂先执行Foo函数。
//返回的是this，而this在构造函数中本来就代表当前实例化对象，遂最终Foo函数返回实例化对象。
//之后调用实例化对象的getName函数，因为在Foo构造函数中没有为实例化对象添加任何属性，因此访问原型对象（prototype）的getName属性。
//一般构造函数没有返回值

new new Foo().getName(); //3，最终实际执行为：new ((new Foo()).getName)();
```

* 变量提升
因为function会先于var声明，因此先读取function
```
console.log(x);//输出：function x(){}
var x=1;
console.log(x);  // 1,这里相当于1覆盖了x(var先声明后复制)
function x(){}
```
但如果为字面量表达式：
```
console.log(x);//输出：function x(){}
var x=1;
function x(){}
```

## http
1. GET和POST有什么区别？
数据传输方式不同：GET请求通过URL传输数据，而POST的数据通过请求体传输。  
安全性不同：POST的数据因为在请求主体内，所以有一定的安全性保证，而GET的数据在URL中，通过历史记录，缓存很容易查到数据信息。  
数据限制不同：数据大小有限制  
GET无害： 刷新、后退等浏览器操作GET请求是无害的，POST可能重复提交表单  
特性不同：GET是安全（这里的安全是指只读特性，就是使用这个方法不会引起服务器状态变化）且幂等（幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同），而POST是非安全非幂等  

2. POST跟PUT区别
『POST表示创建资源，PUT表示更新资源』这种说法是错误的，两个都能创建资源，根本区别就在于幂等性  

3. PUT跟PATCH区别
PUT和PATCH都是更新资源，而PATCH用来对已知资源进行局部更新（可以单一一个字段）。  

4. 响应行
响应行： 由协议版本，状态码和状态码的原因短语组成，例如HTTP/1.1 200 OK。

5. HTTP的keep-alive
在早期的HTTP/1.0中，每次http请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的HTTP/1.0中以及HTTP/1.1中，引入了重用连接的机制，就是在http请求头中加入Connection: keep-alive来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive。
* keep-alive的优点：
较少的CPU和内存的使用（由于同时打开的连接的减少了）  
允许请求和应答的HTTP管线化  
降低拥塞控制 （TCP连接减少了）  
减少了后续请求的延迟（无需再进行握手）  
报告错误无需关闭TCP连    
注意要设置keep-alive的保持连接超时时间，例如client的connectTimeout和readTimeout
