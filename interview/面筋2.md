## ES6补充
es6 class和构造函数的区别   
1.class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。  

2.class 声明内部会启用严格模式。  

3.class 的所有方法（包括静态方法和实例方法）都是不可枚举的。  

4.class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。  

5.必须使用 new 调用 class。  

6.class 内部无法重写类名。  

7.ES5 和 ES6 子类 this 生成顺序不同。ES5 的继承先生成了子类实例，再调用父类的构造函数修饰子类实例，ES6 的继承先生成父类实例，再调用子类的构造函数    

8. 对象解构：
```
let o ={a:1,b:2,c:3}
let {a,...arr} = 0  
console.log(a)//1
console.log(arr)//{b:2,c:3}
console.log(arr.b) //2
```
9. 属性重命名  
let {a:a1,b:b1}=o  
=> let a1 = o.a;
若想指定类型：  
let {a,b} :{a1:String,b1:String} = o  
即是let a1:string　＝　o.a

10. 展开对象  
对象只会展开其自身可枚举属性  
对象展开，后面属性会覆盖前面的属性值
```
let a = {a:3,b:2}
let b = {a:1, ...a} 
console.log(b) //{a:3,b:2}
```


## TypeScripr
1. 类型注解（返回值类型和入参值类型）  
声明变量时进行类型注解：let a : number[] =[6,2,1]
或者元组：let b : [String,number] = ["a",1]，访问对应的元组元素可正确使用原型方法
```
function test(name:String|Array<String>):boolean{
  if(typeof name === 'String'){
    return false 
  }
} 
```
2. 枚举
```
enum Color {Red = 1,Blue}
let a :Color = Color.Red
```

3. 类
```
class Student {
    fullName: string;
    constructor(public firstName, public middleInitial, public lastName) { 
    //在构造函数的参数上使用public等同于创建了同名的成员变量。
        this.fullName = firstName + " " + middleInitial + " " + lastName;
    }
}

interface Person {
    firstName: string;
    lastName: string;
}

function greeter(person : Person) {  
    return "Hello, " + person.firstName + " " + person.lastName;
}

let user = new Student("Jane", "M.", "User");

document.body.innerHTML = greeter(user);
```

4. 类型断言
指定使用的变量的类型:as或者尖括号
```
let someValue: any = "this is a string";
let strLength: number = (<String>someValue).length
let strLength: number = (someValue as string).length;
```

5. 

## ES7
1. 可选链接, 遍历对象判断对象是否存在，如果不存在返回undefined(解决了访问属性报错问题):  
```
{xx:{
    aa:1
}}
xx?.aa || []
```
2. 空值合并   
控制运算符?? ,如左边为空值，则取右边，否则取左边。
（即是分开nullish和falsey值）
```
var a = null
var b = false
a ?? 2  //返回2
b ?? 3  //false
```


3. 动态导入（按需）  
可以在回调函数中import所需文件  
```
()=>{
    import("./xxxx.js")
}.then(module=>{})
```

4. Promise.allSettled与Promise.all区别  
当所有promise执行完成时，才去执行一个任务Promise.all().then(data=>)  
但all()如果执行的Ppromise出现一个报错则无法进行，然而allSettled()不关心结果只需全部执行

5. 接口  
类似java定义类，声明类型  
```
interface Lan{
  label: number,
  label?: number //可选属性
}
function aa(lan:Lan){
  console.dir(lan)
}
aa({label:1});
```

6. 函数入参设为可选参数亦可 （label?:String）   函数设为剩余参数 (...args:String[])

## webpack优化
1.外部引入模块(CDN) 
2.按需引入  
3.tree-shaking  
4.开启gzip  


## 加载海量数据
思路：  
1. 减少dom操作的页面回流 => 使用DocumentFragment 
2. 监听海量元素可以通过父元素进行事件委托
3. 请求ajax频数
4. window.requestAnimationFrame
window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。  
该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行  
返回值：一个 long 整数，请求 ID ，是回调列表中唯一的标识。这个值给 window.cancelAnimationFrame() 以取消回调函数  
注意：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()  

## 作用域
闭包解决方法：
```
for (var i = 0; i < 10; i++) {
    // capture the current state of 'i'
    // by invoking a function with its current value
    (function(i) {
        setTimeout(function() { console.log(i); }, 100 * i);
    })(i);
}

//或者let,块作用域变量在包含它们的块或for循环之外是不能访问的。类似try{}    
//每次迭代都会创建一个新作用域  
for(let i =1;i<=10;i++){
    
        setTimeout(function(){
            console.log(i)
        },100)
}
```

```javascript
function Foo() {
    //没有var声明，先向当前Foo函数作用域内寻找getName变量，再向当前函数作用域上层。
    即外层作用域内寻找是否含有getName变量，也就是第二问中的alert(4)函数，将此变量的值赋值为 function(){alert(1)}。 
    getName = function () { alert (1); };
    return this;
}
Foo.getName = function () { alert (2);};
Foo.prototype.getName = function () { alert (3);};
var getName = function () { alert (4);};
function getName() { alert (5);}

//答案：
//首先定义了一个叫Foo的函数，之后为Foo创建了一个叫getName的静态属性存储了一个匿名函数，之后为Foo的原型对象新创建了一个叫getName的匿名函数。
//之后又通过函数变量表达式创建了一个getName的函数，最后再声明一个叫getName函数。
Foo.getName(); //2

getName(); //4，因为function优先级比var高，然后getName = function()时，覆盖了getName   

Foo().getName(); //1，不一样的是，先执行foo，然后将this指向window，再执行getName，因此调用是window。

getName(); //1，则是再访问getName，由于Foo的getName没有var声明，因此是全局的变量，并覆盖了覆盖外层作用域的alert(4)

new Foo.getName(); //2，点（.）的优先级高于new操作，遂相当于是:new (Foo.getName)();所以实际上将getName函数作为了构造函数来执行

new Foo().getName(); 
//3，看运算符优先级括号高于new，实际执行为(new Foo()).getName()，遂先执行Foo函数。
//返回的是this，而this在构造函数中本来就代表当前实例化对象，遂最终Foo函数返回实例化对象。
//之后调用实例化对象的getName函数，因为在Foo构造函数中没有为实例化对象添加任何属性，因此访问原型对象（prototype）的getName属性。
//一般构造函数没有返回值

new new Foo().getName(); //3，最终实际执行为：new ((new Foo()).getName)();
```

* 变量提升
因为function会先于var声明，因此先读取function
```
console.log(x);//输出：function x(){}
var x=1;
console.log(x);  // 1,这里相当于1覆盖了x(var先声明后复制)
function x(){}
```
但如果为字面量表达式：
```
console.log(x);//输出：function x(){}
var x=1;
function x(){}
```

## http
1. GET和POST有什么区别？
数据传输方式不同：GET请求通过URL传输数据，而POST的数据通过请求体传输。  
安全性不同：POST的数据因为在请求主体内，所以有一定的安全性保证，而GET的数据在URL中，通过历史记录，缓存很容易查到数据信息。  
数据限制不同：数据大小有限制  
GET无害： 刷新、后退等浏览器操作GET请求是无害的，POST可能重复提交表单  
特性不同：GET是安全（这里的安全是指只读特性，就是使用这个方法不会引起服务器状态变化）且幂等（幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同），而POST是非安全非幂等  

2. POST跟PUT区别
『POST表示创建资源，PUT表示更新资源』这种说法是错误的，两个都能创建资源，根本区别就在于幂等性  

3. PUT跟PATCH区别
PUT和PATCH都是更新资源，而PATCH用来对已知资源进行局部更新（可以单一一个字段）。  

4. 响应行
响应行： 由协议版本，状态码和状态码的原因短语组成，例如HTTP/1.1 200 OK。

5. HTTP的keep-alive
在早期的HTTP/1.0中，每次http请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的HTTP/1.0中以及HTTP/1.1中，引入了重用连接的机制，就是在http请求头中加入Connection: keep-alive来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive。
* keep-alive的优点：
较少的CPU和内存的使用（由于同时打开的连接的减少了）  
允许请求和应答的HTTP管线化  
降低拥塞控制 （TCP连接减少了）  
减少了后续请求的延迟（无需再进行握手）  
报告错误无需关闭TCP连    
注意要设置keep-alive的保持连接超时时间，例如client的connectTimeout和readTimeout

6. OSI模型以及TCP/IP
(应用->表示->会话)->传输->网络->(数据链路->物理)  
应用层 HTTP/DNS/FTP -> 传输层 tcp/UDP ->  网络层 IP -> 网络接口层

7. 简述三次握手和四次挥手
下面符号的含义 SYN(联机) ACK(确认) FIN(结束)  
三次握手  
第一次握手：客户端采用TCP协议将带有SYN标志的数据包发送给服务器，等待服务器的确认。  

第二次握手：服务器端在收到SYN的数据包后，必须确认SYN，并发送的ACK标志，同时，自己也将会向客户端发送一个SYN标志。  

第三次握手：客户端在接收到服务器段的SYN+ACK包后，自己会向服务器发送ACK包，完成三次握手。那么客户端和服务器正式建立了连接，开始传输数据。  
四次挥手  
1). 当客户端的数据传输到尾部时，客户端向服务器发送带有FIN标志的数据包，使其明白自己准备断开通信了。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。  

2). 因为TCP的通信是使用全双工通信的，所以在断开连接的时候也应该是双向的；当服务器收到带有FIN标志的数据包时,其必不会直接发送FIN标志断开通信的请求，而是先发送一个带有ACK标志的应答信息，使客户端明白服务器还有数据要进行发送。
   
3). 服务器的数据发送完成后，向客户端发送带有FIN标志的数据包，通知客户端断开连接。

4). 当客户端收到FIN后，担心某些不可控制的因素导致服务器不知道他要断开连接，会发送ACK进行确认，同时把自己设置成TIME_WAIT状态并启动定时器，在TCP的定时器到达后客户端并没有接收到请求，会重新发送；当服务器收到请求后就断开连接；当客户端等待2MLS（两倍报文最大生存时间）后，没有收到请求重传的请求后，客户端这边就断开连接，整个TCP通信就结束了。

为什么握手是三次，挥手是四次  
因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。  
但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文。  
只有等到我Server端所有的报文都发送完了，才能发送FIN报文，因此不能一起发送。故需要四步握手。  

8. https的传输过程
1).在服务器端存在一个公钥及私钥

2).客户端从服务器取得这个公钥

3).客户端产生一个随机的密钥

4).客户端通过公钥对密钥加密（非对称加密）

5).客户端发送到服务器端

6).服务器端接受这个密钥并且以后的服务器端和客户端的数据全部通过这个密钥加密

9. https和http的区别
1).https需要证书。
2).http是超文本传输协议，是明文传输，https则是具有安全性的ssl加密传输协议。
3).http和https使用的端口不同，前者是80，后者是443。
4).http的连接很简单，无状态；HTTPS是由SSL+HTTP构建的可进行加密传输、身份认证的网络协议，比http协议安全。

10. http的状态码中，499是什么？如何出现499，如何排查跟解决
499对应的是 “client has closed connection”，客户端请求等待链接已经关闭，这很有可能是因为服务器端处理的时间过长，客户端等得“不耐烦”了。还有一种原因是两次提交post过快就会出现499。
解决方法：

前端将timeout最大等待时间设置大一些
nginx上配置proxy_ignore_client_abort on

## SEO优化
前端如何进行seo优化

合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可；description把页面内容高度概括，不可过分堆砌关键词；keywords列举出重要关键词。
语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页
重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，保证重要内容一定会被抓取
重要内容不要用js输出：爬虫不会执行js获取内容
少用iframe：搜索引擎不会抓取iframe中的内容
非装饰性图片必须加alt
提高网站速度：网站速度是搜索引擎排序的一个重要指标

## 使用jsonp跨域API
1. 创建script元素，并设为异步调用
2. 获取路径并做加时间戳，防止读取缓存文件
3. 设置加载后的回调函数,以及失败后的回调函数
5. 最后挂载在head标签
```
getByJsonp: function(src,callback,errCB,(charset)){
    document.createElement("script")
    script.async = "async"
    script.charset = charset || 'utf-8'
    script.src = src.indexOf("?")<0 ?　src+"?q="+Math.random() : src+"&q="+Math.random()
    if(callback){
      script.onload = callback;
    }
    if(errCB){
      script.onerror = errCB;
    }
    document.getElementByTagName("head")[0].appendChild(srcipt)=>$().append()
}
```

## 手机返回的回调事件
使用window.onpopstate监听，基于历史记录history
```
watchBackEvt:function(){
  window.onpopstate = function(e){}  //可以获取event状态的信息，如自定义的pageID
}
```
> 拓展：  
每当处于激活状态的历史记录条目发生变化时,popstate事件就会在对应window对象上触发. 如果当前处于激活状态的历史记录条目是由history.pushState()方法创建,或者由history.replaceState()方法修改过的, 则popstate事件对象的state属性包含了这个历史记录条目的state对象的一个拷贝.  
调用history.pushState()或者history.replaceState()不会触发popstate事件. popstate事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮(或者在JavaScript中调用history.back()、history.forward()、history.go()方法).  
```
history.pushState({page: 1}, "title 1", "?page=1");    //添加并激活一个历史记录条目 http://example.com/example.html?page=1,条目索引为1  
history.pushState({page: 2}, "title 2", "?page=2");    //添加并激活一个历史记录条目 http://example.com/example.html?page=2,条目索引为2  
history.replaceState({page: 3}, "title 3", "?page=3"); //修改当前激活的历史记录条目 http://ex..?page=2 变为 http://ex..?page=3,条目索引为3  
history.back(); // 弹出 "location: http://example.com/example.html?page=1, state: {"page":1}"  
history.back(); // 弹出 "location: http://example.com/example.html, state: null  
history.go(2);
```

## 关于框架的路由
disabled-router 该类名表示跳转是直接跳转页面
$.routerLoad("#id") 该方法切换到对应page页面 （page-group多页面切换）
