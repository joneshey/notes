## 加载海量数据
思路：  
1. 减少dom操作的页面回流 => 使用DocumentFragment 
2. 监听海量元素可以通过父元素进行事件委托
3. 请求ajax频数
4. window.requestAnimationFrame
window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。  
该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行  
返回值：一个 long 整数，请求 ID ，是回调列表中唯一的标识。这个值给 window.cancelAnimationFrame() 以取消回调函数  
注意：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()  

## 作用于
```javascript
function Foo() {
    //没有var声明，先向当前Foo函数作用域内寻找getName变量，再向当前函数作用域上层。
    即外层作用域内寻找是否含有getName变量，也就是第二问中的alert(4)函数，将此变量的值赋值为 function(){alert(1)}。 
    getName = function () { alert (1); };
    return this;
}
Foo.getName = function () { alert (2);};
Foo.prototype.getName = function () { alert (3);};
var getName = function () { alert (4);};
function getName() { alert (5);}

//答案：
//首先定义了一个叫Foo的函数，之后为Foo创建了一个叫getName的静态属性存储了一个匿名函数，之后为Foo的原型对象新创建了一个叫getName的匿名函数。
//之后又通过函数变量表达式创建了一个getName的函数，最后再声明一个叫getName函数。
Foo.getName(); //2

getName(); //4，因为function优先级比var高，然后getName = function()时，覆盖了getName   

Foo().getName(); //1，不一样的是，先执行foo，然后将this指向window，再执行getName，因此调用是window。

getName(); //1，则是再访问getName，由于Foo的getName没有var声明，因此是全局的变量，并覆盖了覆盖外层作用域的alert(4)

new Foo.getName(); //2，点（.）的优先级高于new操作，遂相当于是:new (Foo.getName)();所以实际上将getName函数作为了构造函数来执行

new Foo().getName(); 
//3，看运算符优先级括号高于new，实际执行为(new Foo()).getName()，遂先执行Foo函数。
//返回的是this，而this在构造函数中本来就代表当前实例化对象，遂最终Foo函数返回实例化对象。
//之后调用实例化对象的getName函数，因为在Foo构造函数中没有为实例化对象添加任何属性，因此访问原型对象（prototype）的getName属性。
//一般构造函数没有返回值

new new Foo().getName(); //3，最终实际执行为：new ((new Foo()).getName)();
```

* 变量提升
因为function会先于var声明，因此先读取function
```
console.log(x);//输出：function x(){}
var x=1;
console.log(x);  // 1,这里相当于1覆盖了x(var先声明后复制)
function x(){}
```
但如果为字面量表达式：
```
console.log(x);//输出：function x(){}
var x=1;
function x(){}
```
