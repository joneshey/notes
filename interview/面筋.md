## ES6
1. let和var区别: 
不存在变量提升；
```
console.log(c)  //undefined，如果是let会直接报错
var c = 1;
=> var c;
c = 1
```  
同一个作用域不能重复定义；  
  
有严格的作用域，var是函数作用域，let是块级作用域  

* const如果是常量不能改变，但如果是对象则可以修改内部属性。  

2.  箭头函数
v为参数，v+1返回值  
`var a = v => v+1`  
无参数  
`var a = () => 2`  
*this执行外层定义的主体而不是调用的主体。  
*无法使用 new 实例化对象 因为普通构造函数通过 new 实例化对象时 this 指向实例对象，而箭头函数没有 this 值，同时 箭头函数也没有 prototype。

this指向栗子：  
```
let name = 'a'
var a = {
  name: 'b',
  getName:function(){
    let print = ()=>{console.log(this.name)}
    return print;
  }
}
a.getName()()  // b,因为print的外层调用者为a

let name = 'a'
var a = {
  name: 'b',
  getName:()=>{
    let print = ()=>{console.log(this.name)}
    return print;
  }
}
a.getName()()  // a,因为定义的是继承getName的外层调用者window,getName也是个箭头函数

```   
因此想要获取某个代码块的this，可以使用function打破箭头函数的继承

3. set、map结构函数
set 类似数组，成员唯一  （转变数组[...new Set()]）   
map 键可以是对象  可以使用for of会把原型也进行遍历，且要注意兼容性（for in要数组）

4. 模块字符串
反义字符串：反单引号``  
<a>${val}</a> //val为变量

## 瀑布流
获取图片高度、宽度 
1. 等宽不等高  
（第一排排列，第二排需要定位，w=(n-1)*w+w h=第一排第一张高度）
top: 最小图片的高度  
创建数组存储高度，遍历所有图片，存储高度到数组中。  
找到第1排的图片的高度，如果是第一排则设置top,否则找到最小的高度索引，相加定位高度。  
意思是：找到最小高度后，将该高度相加设为该图片的顶部距离，此时最小高度不再是原来索引，因此再次去找新的最小高度索引。
* 求最小值 Math.min(...arr)  查找索引$.inArray(n)//相当于indexOf

## 作用域
无调用者 this为window  
```
var length = 10;
function f1(){clg(this.length)}
var obj = {
    f2:function(f1){
        f1()  //无调用者，指向window，10
        arguments[0]()   //arguments作用域指向arguments对象,2 
    }
}
obj.f2(f1,1)
```
谁调用this指向谁，argument[0]()则调用者为argument对象，因此arguments.length为参数个数  
apply参数传数组，代表n个形参；call需要单个传


坑题：
```
var b=1;
function test(){
    b=100;
    console.log(b) //100，读的是var b test作用域
    console.log(this.b) //10，指向window
    var b;  //变量提升，先定义，此时a已经有值100
}
test()
```
```
var b=1;
function test(){
    b=100;
    console.log(b) //100
    console.log(this.b) //100，指向window，但window的全局b被覆盖
}
test()
```
```
(function(){
    var a=b=3;
    //b没声明成了全局
})
console.log(b)//3，内部作用域没声明则作为全局变量，会影响覆盖全局
```
* 函数优先级最高
```
for(var i =1 ;i<=3;i++){
    setTimeout(function(){
        console.log(i)
    },0)
}
当i=3则会继续i++,判断i=4>3则中断，因此打印出444
```

## 跨域
1. 解决方法  nginx反向代理 webpack proxy代理(打包后就没了这个配置)  jsonp cors
cors是在后端增加header:(Access-Control-Allow-Origin,"")//Methods、Headers

webpack-dev-middleWare中间件，直接使用前端的服务webpack.config.js且经过webpack编译（在后端）

## 懒加载
通过data-src存储路径，按需加载
scorll()  
```
st = window.scrollTop()//滚动条与顶部高度
current = window.height()  //当前页面高度，因此要向上取
total = document.height()//页面总高度
if(st + current >= total){  //会出现小于总高度的时候无法加载的情况
    //加载
}
```
