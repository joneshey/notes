# 开发基础知识点
* ### 闭包  
闭包就是在函数中，内部作用域中可以使用外部作用于的变量。
引起问题：当外部函数返回一个匿名函数，容易造成内存泄漏，导致内部变量一直被引用，无法回收。  
举个栗子：
  ```javascript
  var func = function(){
      var a = 3;
      return function(b){   //return 后导致s变量一直被引用
        var s=a+b;   //引用了外部作用域的a变量
        return s;
      };
  }
  func()(3);  //6

  =>等价于

  var f = func();  //返回匿名函数
  f(3);
  ```
  而在for循环使用闭包时,会遇到前端司空见惯的闭包问题。
 ```javascript
 var arr = []; //new Array  
 for (var i=0; i<5; i++) {
   arr[i] = function(){
       return i;
   }
 } 
 console.log(arr)  //JavaScript第三版，但实际运行结果返回5个声明函数
 //原因是function()闭包保存的是变量对象，每当i发生变化，会找到引用对象的地址修改原来的值（类似修改数组对象）
 
 for (var i=0; i<5; i++) {
   setTimeout( function timer() {
     console.log( i );
   }, i*1000 );
 } 
 //5 5 5 5 5 => 原因是函数执行顺序，主逻辑for循环先执行完，setTimeOut(function(),ms)才去执行，导致这时候的i==5
 //而即使setTimeOut为0，结果也相同
```
  解决办法：使用立即执行函数，给闭包提供一个单独作用域
```javascript
 for (var i=1; i<=5; i++) {
   (function(j){
      setTimeout(function(){
          console.log( j );  //12345
           console.log(i);   //66666
      }, i*1000 );
   })(i); //单独传值变量
    console.log(i); //12345
 } 
```
  同理：DOM元素的onclick事件也是一样，因为点击时主逻辑for已经遍历完，i已经为6。
  
* ### CSS媒体查询
@media screen and (max-width:xxxpx) and (min-width:xxxpx){}  
通常I6为准 I6:375*667  I5:320*568  
而实际会偏向临界值进行自适应

* ### 适配meta标签
`<meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"/>`  
注： viewport表示显示视口，content里定义字段：width适应的宽度（虚拟窗口的宽度），设为设备宽度；视口比例大小（虚拟窗口和页面窗口的比例），设为1:1；最大/小缩放大小；能否自定义缩放。  
> 以下为网上经验：  
> 1. user-scalable=no就一定可以保证页面不可以缩放吗？NO，有些浏览器不吃这一套，还有一招就是minimum-scale=1.0, maximum-scale=1.0 最大与最小缩放比例都设为1.0就可以了。  
> 2. initial-scale=1.0 初始缩放比例受user-scalable控制吗？不一定，有些浏览器会将user-scalable理解为用户手动缩放，如果user-scalable=no，initial-scale将无法生效。  
> 3. 手机页面可以触摸移动，但是如果有需要禁止此操作，就是页面宽度等于屏幕宽度是页面正好适应屏幕才可以保证页面不能移动。  
> 4. 如果页面是经过缩小适应屏幕宽度的，会出现一个问题，当文本框被激活（获取焦点）时，页面会放大至原来尺寸。

* ### 异步请求AJAX
1. 原生 
```
var xhr = new XMLHttpRequest()
xhr.open('get',url,async);  //async异步或同步
// xmlHttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");//用post方法的话，一定要加这句设置请求头的contentType属性
xhr.onreadystatechange=function(){} // 根据xhr.readyState,status,有5个可取值0=未初始化 ，1=正在加载，2=已加载，3=交互中，4=完成
xhr.send(data);  //xx=yy&aa=bb
```

2. axios
```
//发起一个GET请求
axios.get('/user', {
    params: {
      ID: 12345
    }
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
  
//发起一个POST请求
axios.post()

同时发起多个请求
function getUserAccount() {
  return axios.get('/user/12345');
}

function getUserPermissions() {
  return axios.get('/user/12345/permissions');
}

axios.all([getUserAccount(), getUserPermissions()])
  .then(axios.spread(function (acct, perms) {
    // Both requests are now complete
  }));
```

3. jQuery
```
function a(){
   return $.ajax({});
}
a.then(function(data){
   //callbackContent
})
```
