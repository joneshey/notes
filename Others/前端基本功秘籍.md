# 开发基础知识点
* ### 闭包  
闭包就是在函数中，内部作用域中可以使用外部作用于的变量。
引起问题：当外部函数返回一个匿名函数，容易造成内存泄漏，导致内部变量一直被引用，无法回收。  
举个栗子：
  ```javascript
  var func = function(){
      var a = 3;
      return function(b){   //return 后导致s变量一直被引用
        var s=a+b;   //引用了外部作用域的a变量
        return s;
      };
  }
  func()(3);  //6

  =>等价于

  var f = func();  //返回匿名函数
  f(3);
  ```
  而在for循环使用闭包时,会遇到前端司空见惯的闭包问题。
 ```javascript
 var arr = []; //new Array  
 for (var i=0; i<5; i++) {
   arr[i] = function(){
       return i;
   }
 } 
 console.log(arr)  //JavaScript第三版，但实际运行结果返回5个声明函数
 //原因是function()闭包保存的是变量对象，每当i发生变化，会找到引用对象的地址修改原来的值（类似修改数组对象）
 
 for (var i=0; i<5; i++) {
   setTimeout( function timer() {
     console.log( i );
   }, i*1000 );
 } 
 //5 5 5 5 5 => 原因是函数执行顺序，主逻辑for循环先执行完，setTimeOut(function(),ms)才去执行，导致这时候的i==5
 //而即使setTimeOut为0，结果也相同
```
  解决办法：使用立即执行函数，给闭包提供一个单独作用域
```javascript
 for (var i=1; i<=5; i++) {
   (function(j){
      setTimeout(function(){
          console.log( j );  //12345
           console.log(i);   //66666
      }, i*1000 );
   })(i); //单独传值变量
    console.log(i); //12345
 } 
```
  同理：DOM元素的onclick事件也是一样，因为点击时主逻辑for已经遍历完，i已经为6。
  
* ### CSS媒体查询
@media screen and (max-width:xxxpx) and (min-width:xxxpx){}  
通常I6为准 I6:375*667  I5:320*568  
而实际会偏向临界值进行自适应

* ### css-background
```css
background:url('') no-repeat (水平方向)center (垂直方向)0
background-size: contain ; （按比例缩放）
```

* ### 适配meta标签
`<meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"/>`  
注： viewport表示显示视口，content里定义字段：width适应的宽度（虚拟窗口的宽度），设为设备宽度；视口比例大小（虚拟窗口和页面窗口的比例），设为1:1；最大/小缩放大小；能否自定义缩放。  
> 以下为网上经验：  
> 1. user-scalable=no就一定可以保证页面不可以缩放吗？NO，有些浏览器不吃这一套，还有一招就是minimum-scale=1.0, maximum-scale=1.0 最大与最小缩放比例都设为1.0就可以了。  
> 2. initial-scale=1.0 初始缩放比例受user-scalable控制吗？不一定，有些浏览器会将user-scalable理解为用户手动缩放，如果user-scalable=no，initial-scale将无法生效。  
> 3. 手机页面可以触摸移动，但是如果有需要禁止此操作，就是页面宽度等于屏幕宽度是页面正好适应屏幕才可以保证页面不能移动。  
> 4. 如果页面是经过缩小适应屏幕宽度的，会出现一个问题，当文本框被激活（获取焦点）时，页面会放大至原来尺寸。

* ### 异步请求AJAX
1. 原生 
```javascript
var xhr = new XMLHttpRequest()

xhr.open('get',url,async);  //async异步或同步

// xmlHttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
//用post方法的话，一定要加这句设置请求头的contentType属性

xhr.onreadystatechange=function(){} 
// 根据xhr.readyState,status,有5个可取值0=未初始化 ，1=正在加载，2=已加载，3=交互中，4=完成

xhr.send(data);  
//xx=yy&aa=bb
```

2. axios
```javascript
//发起一个GET请求
axios.get('/user', {
    params: {
      ID: 12345
    }
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
  
//发起一个POST请求
axios.post()

//同时发起多个请求
function getUserAccount() {
  return axios.get('/user/12345');
}

function getUserPermissions() {
  return axios.get('/user/12345/permissions');
}

axios.all([getUserAccount(), getUserPermissions()])
  .then(axios.spread(function (acct, perms) {
    // Both requests are now complete
  }));
```

3. jQuery
```javascript
function a(){
   return $.ajax({});
}

a.then(function(data){
   //callbackContent
})
```

* ### Hack
> flex布局分为旧版本dispaly: box；过渡版本dispaly: flex box；以及现在的标准版本display: flex；
* Android  
2.3 开始就支持旧版本display:-webkit-box;  
4.4 开始支持标准版本display: flex;  

* IOS:  
6.1 开始支持旧版本display:-webkit-box;  
7.1 开始支持标准版本display: flex;  

* PC  
ie10开始支持，但是IE10的是-ms形式的  

> 注意：css向下兼容指的是旧版本无法读取新版本的属性值，但由于新版本支持该属性值，因此旧版本会覆盖新版本的display，因此应该把旧版本放在新版本前面。-webkit-box  

* 盒子写法
```css
display:-webkit-flex;      /* 新版本语法: Chrome 21+ */
display:flex;                  /* 新版本语法: Opera 12.1, Firefox 22+ */
display:-webkit-box;    /* 老版本语法: Safari, iOS, Android browser, older WebKit browsers. */
display:-moz-box;      /* 老版本语法: Firefox (buggy) */
display:-ms-flexbox;  /* 混合版本语法: IE 10 */
```

* 子元素写法
```css
-webkit-flex:1;        /* Chrome */  
-ms-flex:1;              /* IE 10 */  
flex:1;                     /* NEW, Spec - Opera 12.1, Firefox 20+ *
-webkit-box-flex:1  /* OLD - iOS 6-, Safari 3.1-6 */
-moz-box-flex:1;      /* OLD - Firefox 19- */
```
1. CSS 内部hack
CSS 内部hack 语法是这样的 selector{?property:value?;} 比如IE6能识别下划线"“和星号”"，IE7能识别星号""，但不能识别下划线""，而firefox两个都不能认识。对于书写顺序的关系，一般是将识别能力强的浏览器的CSS写在后面。
```css
<style> 
div{  
    background:green;/*forfirefox*/  
    *background:red;/*forIE6 IE7*/  
}  
</style> 
```
这样的话就成功对IE6,7 做了一次hack;  
再比如，“!important”的写法只有IE6不能识别，其它版本IE及现代浏览器都可以识别  

2. 选择器hack
选择器hanck主要是针对IE浏览器，其实并不怎么常用  
语法是这样的： selector{ sRules }  
针对IE9的hack可以这么写  
```css
:root .test
{
    background-color:green;
}
```
3. HTML 头部引用
HTML头部引用就比较特殊了，类似于程序语句，只能使用在HTML文件里，而不能在CSS文件中使用，并且只有在IE浏览器下才能执行，在其他浏览器下面会被当做注释视而不见。 
```html
<!– 默认先调用css.css样式表 –>
<link rel="stylesheet" type="text/css" href="css.css" />
<!–[if IE 7]>
<!– 如果IE浏览器版是7,调用ie7.css样式表 –>
<link rel="stylesheet" type="text/css" href="ie7.css" />
<![endif]–>
<!–[if lte IE 6]>
<!– 如果IE浏览器版本小于等于6,调用ie.css样式表 –>
<link rel="stylesheet" type="text/css" href="ie.css" />
<![endif]–>
```
> 注：
> lte：就是Less than or equal to的简写，也就是小于或等于的意思。  
> lt ：就是Less than的简写，也就是小于的意思。  
> gte：就是Greater than or equal to的简写，也就是大于或等于的意思。  
> gt ：就是Greater than的简写，也就是大于的意思。  
> ! ：就是不等于的意思，跟javascript里的不等于判断符相同。  

* ### SSL攻击
SQL注入：通常在查询条件下，插入参数，因此该参数不能通过用户输入设置  
撞库攻击：需要用使用人工验证防止被爬，如识别图案、滑动拖条

* ### 缓存
实现缓存首先要知道需求的有效时间的多长，从而移除缓存。（通过添加时间戳去判断时效性）  
主要为了永久保存某些数据，在多个页面可以获取，key需要对应客户的唯一性。  
页面的数据不能完全依赖缓存获取，先做判断，如果缓存没有则调用接口。  
setItem();removeItem()

* ### 解决历史记录
切换tabs后，点击跳转。在浏览器返回时回到上次的tab  
`history.replaceState({url:'',title:''},title,url)`  //hash#aa
在切换时，用replaceState给历史记录插入一个地址，返回时就会回到当前tab

> 实际开发的时候更为复杂，有个tab页面要根据hash进行类型选中
